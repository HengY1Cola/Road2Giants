## 三面问题：简单写写

- set如何实现 使用map实现

- tcp粘包/拆包 解决思路：规定长度；标志符；明白为什么产生

- go垃圾回收 三色+写屏障+辅助gc 一次回收的过程 三色与标准清除的差别

- Mysql覆盖索引 常见的方法是：将被查询的字段，建立到联合索引里去

- 说一下聚簇索引 主键；不空且唯一；隐藏的row_id

- 死锁算法/条件/打破 ：银行家算法/4个条件/打破其中一个具体点/说一下Mysql死锁的场景

- 描述一些生产者消费者问题： go实现生产者消费者 协程生产 main消费

- 虚拟存储 段页式存储管理 程序按模块分段，每个段再分成与物理空间页同样小的页面

- 地址翻译的过程 TLB->页表->Cache->主存->外存

- socket：明白2对以及相关函数

- 烧绳子：知道如何烧出15分钟就好了

- 分布式id生成怎么搞：数据库自增ID，UUID生成，雪花算法

- 数据库中是如何保证原子性的：原子性的保证是利用了undo log

- 虚拟内存换页算法：最佳；先入先出；LRU；Clock

- 线程共享内容：数据段与文件描述符号（fd）；有自己的私有栈

- 聚簇索引与非聚簇索引区别：

  聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据

  二级索引的叶子节点存放的是主键值或指向数据行的指针，可以使用覆盖索引进行优化

- 为什么要使用B+

  哈希虽然能够提供O(1)但是对于范围查询和排序却无法很好地支持

  B 树能够在非叶节点中存储数据，但是这也导致在查询连续数据时可能会带来更多的随机 I/O

  而 B+ 树的所有叶节点可以通过指针相互连接，能够减少顺序遍历时产生的额外随机 I/O

- Mysql使用B+而redis使用跳表

  redis 是内存数据库，而 B + 树纯粹是为了 mysql 这种 IO 数据库准备的

  Redis 中的有序集合按照区间来查找数据这个操作，**跳表**可以快速定位并且遍历就好了

- 替换进程的时候，操作系统具体干了什么：

  操作系统维护了一组状态队列，当一个进程的状态发生变化时，它的PCB会从一个状态队列中脱离出来加入到另一个状态队列

- 栈和堆的区别。为什么要设计出栈和堆

  堆由低地址向高地址扩展，栈由高地址向低地址扩展。

  堆中的内存手动申请，手动释放；栈中内存由操作系统自动申请释放

  堆会频繁调用new和free，产生内存碎片，降低效率

- 什么是自旋锁 自旋锁是通过 CPU 提供的 `CAS` 函数不会主动产生线程上下文切换利用 CPU 周期，直到锁可用

- 跨域保持登录状态 token；门户网站跳转；前端存入localstorage

- redis与mysql的一致性问题 删除更新/更新删除/延时双删

- 进程切换 刷新页表；切换内核栈

- 为什么要设计最左匹配原则 联合索引是B+树；最左匹配原则遇上范围查询就会停止，剩下的字段都无法使用索引

- Mysql分表的问题以及设计

  同一个业务数据量大之后，进行水平拆分：range；hash；**垂直拆分**从业务角度进行拆分多个库

- redis实现消息队列以及延时队列

  rpush；lpop；blpop；

  zset用设置好的时间戳作为score进行排序；zrangebysocre 查询符合条件的所有待处理的任务；计时器

- 高并发下点赞，取消点赞、点赞计数的设计

- 短链接的设计：位数；一对多；跳转；如何生成

- 视频网站上传设计：

  - 断点上传；记录顺序；合并文件；文件打开缓冲区以及关闭；
  - 文件名的hash；进度条；验证完全hash；再次上传的hash验证
  - 下发的带宽；CDN