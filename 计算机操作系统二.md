# 面向面试的计操总结

## 如何让程序跑的更快？

**CPU** 时钟周期数（**CPU Cycles**）和时钟周期时间（**Clock Cycle Time**）的乘积

时钟周期时间就是我们前⾯提及的 CPU 主频，根据买的CPU决定。

如果能减少程序所需的 CPU 时钟周期数量，⼀样也是能提升程序的性能的。

对于 CPU 时钟周期数我们可以进⼀步拆解成：指令数 **x** 每条指令的平均时钟周期数

##  64 位相⽐ 32 位 CPU 的优势在哪吗？64 位 CPU 的计算性能⼀定⽐ 32 位 CPU ⾼很多吗？

64 位 CPU 可以⼀次计算超过 32 位的数字，⽽ 32 位 CPU 如果要计算超过 32 位的数字，要分多步骤进⾏计算

64 位 CPU 可以寻址更⼤的内存空间，32 位 CPU 最⼤的寻址地址是 4G

如果 32 位指令在 64 位机器上执⾏，需要⼀套兼容机制，就可以做到兼容运⾏了

但是如果 **64** 位指令在 **32** 位机器上执⾏，就⽐较困难了，因为 **32** 位的寄存器存不下 **64** 位的指令；

##  各种存储器之间的关系

CPU 可以⽐喻成我们的⼤脑，我们当前正在思考和处理的知识的过程，就好⽐ CPU 中的寄存器处理数据的过程，速度极快，但是容量很⼩。⽽ CPU 中的 **L1-L3 Cache** 好⽐我们⼤脑中的短期记忆和⻓期记忆，需要⼩⼩花费点时间来调取数据并处理。

我们⾯前的桌⼦就相当于内存，能放下更多的书（数据），但是找起来和看起来就要花费⼀些时间，相⽐ CPU Cache 慢不少。⽽图书馆的书架相当于硬盘，能放下⽐内存更多的数据，但找起来就更费时间了，可以说是最慢的存储器设备了。

##  如何写出让 **CPU** 跑得更快的代码

访问的数据在 CPUCache 中的话，意味着缓存命中，缓存命中率越⾼的话，代码的性能就会越好，CPU 也就跑的越快

例如：遇到这种遍历数组的情况时，按照内存布局顺序访问，将可以有效的利⽤ **CPU Cache**带来的好处

##  如何提升指令缓存的命中率？

如果分⽀预测可以预测到接下来要执⾏ **if** ⾥的指令，还是 **else** 指令的话，就可以「提前」把这些指令放在指令缓存中，这样 **CPU** 可以直接从 **Cache** 读取到指令，于是执⾏速度就会很快

##  如果提升多核 CPU 的缓存命中率？

虽然 L3 Cache 是多核⼼之间共享的，但是 L1 和 L2 Cache 都是每个核⼼独有的，如果⼀个进程在不同核⼼来回切换，各个核⼼的缓存命中率就会受到影响。当有多个同时执⾏「计算密集型」的线程，为了防⽌因为切换到不同的核⼼，⽽导致缓存命中率下降的问题，我们可以把线程绑定在某⼀个 **CPU** 核⼼上，这样性能可以得到⾮常可观的提升

##  避免伪共享的⽅法

什么是伪共享搞清楚。应该避免这些数据刚好在同⼀个 Cache Line 中，否则就会出现为伪共享的问题

##  负数为什么要⽤补码⽅式来表示

如果负数不是使⽤补码的⽅式表示，则在做基本对加减法运算的时候，还需要多⼀步操作来判断是否为负数，如果为负数，还得把加法反转成减法，或者把减法反转成加法

##  计算机是怎么存⼩数的

符号位 + 指数位 + 尾数位：⽤ 32 位来表示的浮点数，则称为单精度浮点数，也就是我们编程语⾔中的 float 变量，⽽⽤64 位来表示的浮点数，称为双精度浮点数，也就是 double 变量

##  内核有哪些能⼒呢？

- 管理进程、线程，决定哪个进程、线程使⽤ CPU，也就是进程调度的能⼒
- 管理内存，决定内存的分配和回收，也就是内存管理的能⼒；
- 管理硬件设备，为进程与硬件设备之间提供通信能⼒，也就是硬件通信能⼒；
- 提供系统调⽤，如果应⽤程序要运⾏更⾼权限运⾏的服务，那么就需要有系统调⽤，它是⽤户程序与操作系统之间的接⼝。

## 并发或并⾏

- 对于单核 CPU 时，可以让每个任务执⾏⼀⼩段时间，时间到就切换另外⼀个任务，从宏观⻆度看，⼀段时间内执⾏了多个任务，这被称为并发。
- 对于多核 CPU 时，多个任务可以同时被不同核⼼的 CPU 同时执⾏，这被称为并⾏

## 分段机制下，虚拟地址和物理地址是如何映射的？

分段机制下的虚拟地址由两部分组成，段选择⼦和段内偏移量（汇编语言中的8086机器）

分段的好处就是能产⽣连续的内存空间，但是会出现内存碎⽚和内存交换的空间太⼤的问题

##  分⻚机制下，虚拟地址和物理地址是如何映射的？

在分⻚机制下，虚拟地址分为两部分，⻚号和⻚内偏移。⻚号作为⻚表的索引，⻚表包含物理⻚每⻚所在物理内存的基地址，这个基地址与⻚内偏移的组合就形成了物理内存地址。但是光光简单分页完全是不够的，⻚表会很大。

##  线程的优缺点？

- 线程的优点：
  - ⼀个进程中可以同时存在多个线程；
  - 各个线程之间可以并发执⾏；
  - 各个线程之间可以共享地址空间和⽂件等资源；

- 线程的缺点：
  - 当进程中的⼀个线程崩溃时，会导致其所属进程的所有线程崩溃。

##  线程与进程的⽐较

- 进程是资源（包括内存、打开的⽂件等）分配的单位，线程是 CPU 调度的单位；
- 进程拥有⼀个完整的资源平台，⽽线程只独享必不可少的资源，如寄存器和栈；
- 线程同样具有就绪、阻塞、执⾏三种基本状态，同样具有状态之间的转换关系；
- 线程能减少并发执⾏的时间和空间开销；

##  **进程和线程的区别？**

- 调度：进程是资源管理的基本单位，线程是程序执行的基本单位。
- 切换：线程上下文切换比进程上下文切换要快得多。
- 资源： 进程是拥有资源的一个独立单位，线程是分割CPU具有一定数量的栈与寄存器

- 系统开销：进程的开销也远大于线程开销。

##  协程与线程的区别？

- 线程和进程都是同步机制，而协程是异步机制。
- 线程是抢占式，而协程是非抢占式的。此同一时间协程拥有运行权，相当于单线程的能力
- 一个线程可以有多个协程，一个进程也可以有多个协程
- 协程能保留上一次调用时的状态
- 协程不被操作系统内核管理，而完全是由程序控制。

## **并发和并行有什么区别？**

并发就是在一段时间内，多个任务都会被处理；但在某一时刻，只有一个任务在执行

并行就是在同一时刻，有多个任务在执行

##  **进程与线程的切换流程**

1. 切换**页表**以使用新的地址空间，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了
2. 切换内核栈和硬件上下文

进程切换以上两步；线程切换只有第一步。

## **为什么虚拟地址空间切换会比较耗时**

进程会有虚拟地址空间，会通过页表换为物理地址需要查找页表，但是查询页表很慢，则会因使用缓存来做地址映射，这样这个 Cache 就是 TLB。由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么**当进程切换后页表也要进行切换，页表切换后 TLB 就失效了**，Cache 失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致 TLB 失效，因为线程无需切换地址空间，因此我们通常说线程切换要比较进程切换块，原因就在这里。

## **进程间通信方式有哪些？**

- **管道**：**匿名管道和命名管道** Linux中的 ｜ 

- **信号**：kill -9

- 信号量：PV；不能传递复杂消息，只能用来同步

- 消息队列：消息队列是消息的链接表；要考虑上一次没有读完数据的问题

- 共享内存：这段共享内存由一个进程创建，但多个进程都可以访问

- Socket：用于不同机器之间

##  **进程间同步的方式有哪些**

- **临界区**：只能用来同步本进程内的线程
- **互斥量**：可以在不同应用程序的线程之间实现对资源的安全共享
- 信号量：不能用于分布式操作系统；难以控制，读写和维护都很困难
- **事件**：通知线程有一些事件已发生，从而启动后继任务的开始

##  **什么是临界区，如何解决冲突**

**一次仅允许一个进程使用的资源称为临界资源**

- 如果有若干进程要求进入空闲的临界区，**一次仅允许一个进程进入**

- 进入临界区的进程要在**有限时间内退出**。 抢占式

- 如果进程不能进入自己的临界区，则应**让出 CPU**，避免进程出现“忙等”现象。

##  **死锁产生的条件**

- 互斥条件
- 请求与保持条件
- 不剥夺条件
- 循环等待条件

##  **进程调度策略有哪几种**

- **先来先服务**
- **短作业优先**
- **最短剩余时间优先**
- **时间片轮转**
- 最高响应比优先
- 公平共享调度

##  **进程有哪些状态**

进程一共有 5 种状态，分别是创建、就绪、运行（执行）、终止、阻塞

## **什么是分页**

把内存空间划分为**大小相等且固定的块**，作为主存的基本单位。因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，**因此需要一个页表来记**录映射关系，以实现从页号到物理块号的映射

## **什么是分段**

分段内存管理当中，**地址是二维的，一维是段号，二维是段内地址；其中每个**段的长度是不一样的，而且每个段内部都是从 0 开始编址的

## **分页和分段有什区别**

- 分页对程序员是透明的，但是分段需要程序员显式划分每个段。

- 分页的地址空间是一维地址空间，分段是二维的。

- 页的大小不可变，段的大小可以动态改变。

- 分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。

##  **什么是交换空间**

操作系统把物理内存(physical RAM)分成一块一块的小内存，每一块内存被称为**页(page)**。当内存资源不足时，**Linux 把某些页的内容转移至硬盘上的一块**空间上，以释放内存空间**。硬盘上的那块空间叫做**交换空间**(swap space),而这一过程被称为交换(swapping)。**物理内存和交换空间的总容量就是虚拟内存的可用容量

## **页面替换算法有哪些**

- **最佳算法**：所选择的被换出的页面将是最长时间内不再被访问
- **先进先出**
- **LRU**
- **时钟算法**

##  **什么是缓冲区溢出？有什么危害**

缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上

- 崩溃
- 恶意执行

##  **什么是虚拟内存？**

让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存

##  **讲一讲 IO 多路复用**

**指内核一旦发现进程指定的一个或者多个 IO 条件准备读取，它就通知该进程**

##  简述操作系统如何进行内存管理

**操作系统内存管理包括物理内存管理和虚拟内存管理**：

物理内存管理：包括程序装入等概念、交换技术、连续分配管理方式和非连续分配管理方式（分页、分段、段页式）。

虚拟内存管理：虚拟内存管理包括虚拟内存概念、请求分页管理方式、页面置换算法、页面分配策略、工作集和抖动。

##  简述创建进程的流程

1.映射EXE文件：第一步就是将该exe文件放在内存中，如上文A.exe,每个exe内部都有说明，自己存放的位置。

2.每个进程都有一个EPROCESS（结构体）对象，它被放在内核区。

3.映射系统DLL：ntdll.dll被放在用户区。

4.创建进程的时候必然会自动创建一个线程，创建在内核区，如上图。

5.运行A.exe，除开ntdll.dll外，将系统中其它dll也放在用户空间中。

6.线程开始执行。

##  简述僵尸进程和孤儿进程及其危害和处理

**孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。**

**僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。**

1. **其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程**

2. **孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上**。**因此孤儿进程并不会有什么危害。**

1. **通过信号机制**：子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。
2. 将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程

##  两个线程交替打印一个共享变量

python中condition的使用：`.notify()`与`.wait()`顾名思义：一个通知一个等待

##  进程通信中的管道实现原理是什么

管道是由内核管理的一个缓冲区，相当于我们放入内存中的一个纸条。
管道的一端连接一个进程的输出。这个进程会向管道中放入信息。
管道的另一端连接一个进程的输入，这个进程取出被放入管道的信息。
一个缓冲区不需要很大一般为4K大小，它被设计成为环形的数据结构，以便管道可以被循环利用。
当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。
当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。
当两个进程都终结的时候，管道也自动消失。

##  简述同步与异步的区别，阻塞与非阻塞的区别

**1.同步与异步**
同步和异步关注的是**[消息通信机制](https://www.zhihu.com/search?q=消息通信机制&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A20851256})** (synchronous communication/ asynchronous communication)
所谓同步，就是在发出一个*调用*时，在没有得到结果之前，该*调用*就不返回。但是一旦调用返回，就得到[返回值](https://www.zhihu.com/search?q=返回值&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A20851256})了。
换句话说，就是由*[调用者](https://www.zhihu.com/search?q=调用者&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A20851256})*主动等待这个*调用*的结果。

而异步则是相反，***调用\*在发出之后，这个调用就直接返回了，所以没有返回结果**。换句话说，当一个[异步过程](https://www.zhihu.com/search?q=异步过程&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A20851256})调用发出后，调用者不会立刻得到结果。而是在*调用*发出后，*被调用者*通过状态、通知来通知调用者，或通过回调函数处理这个调用。

2. 阻塞与非阻塞；阻塞和非阻塞关注的是**程序在等待调用结果（消息，返回值）时的状态.**

[阻塞调用](https://www.zhihu.com/search?q=阻塞调用&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A20851256})是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

##  什么情况下，进程会进行切换？

- 某个进程的时间片耗尽了
- 系统资源不足（比如内存不足）时
- 进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度
- 有优先级更高的进程运行
- 发生硬件中断时

##  Linux 系统态与用户态，什么时候会进入系统态

Linux的设计的初衷：**给不同的操作给与不同的“权限”**。Linux操作系统就将权限等级分为了2个等级，分别就是内核态和用户态

用户态到内核态切换可以通过三种方式：

1. 系统调用，这个上面已经讲解过了，在我公众号之前的文章也有讲解过。其实系统调用本身就是中断，但是软件中断，跟硬中断不同。
2. 异常：如果当前进程运行在用户态，如果这个时候发生了异常事件，就会触发切换。例如：缺页异常。
3. 外设中断：当外设完成用户的请求时，会向CPU发送中断信号。

##  共享内存是如何实现的

一旦这样的内存映射到共享它的进程的[地址空间](https://so.csdn.net/so/search?q=地址空间&spm=1001.2101.3001.7020)，这些进程间数据传递不再涉及到内核，换句话说是进程不再通过执行进入内核的系统调用来传递彼此的数据。

##  线程间有哪些通信方式

- 锁机制：包括互斥锁、条件变量、读写锁
- 信号量机制
- 信号机制

##  Linux 进程调度的算法

Linux在进行进程调度的时候把进程分为两种：**1.普通进程；2.实时进程**

**普通进程的调度采用的是完全公平调度（CFS）对应的是SCHED_NORMAL**

**CFS的出发点**基于一个非常简单的概念：**进程调度的效果应如同系统具备一个理想中的完美多任务处理器。**在这种系统中每个进程将能获得1/n的处理器时间

**Linux提供了两种实时调度策略：先入先出和时间片轮转。**

##  Linux 虚拟内存是什么以及页面置换算法

当每个进程创建的时候，内核会为进程分配4G的虚拟内存，当进程还没有开始运行时，这只是一个内存布局。实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射）。这个时候数据和代码还是在磁盘上的。当运行到对应的程序时，进程去寻找页表，发现页表中地址没有存放在物理内存上，而是在磁盘上，于是发生缺页异常，于是将磁盘上的数据拷贝到物理内存中。

另外在进程运行过程中，要通过malloc来动态分配内存时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。

可以认为虚拟空间都被映射到了磁盘空间中（事实上也是按需要映射到磁盘空间上，通过mmap，mmap是用来建立虚拟空间和磁盘空间的映射关系的）

- **最佳置换算法**：每次选择未来长时间不被访问的或者以后永不使用的页面进行淘汰
- **先进先出页面置换算法**：淘汰最先进入内存的页面
- **最近最少使用置换算法**（LRU）：选择最近且最久未被使用的页面进行淘汰

##  Linux 中虚拟内存和物理内存有什么优点？

- 虚拟内存可以利用内存起到缓存的作用，提高进程访问磁盘的速度
- 虚拟内存可以为进程提供独立的内存空间，可以实现内存共享
- 虚拟内存可以控制进程对物理内存的访问，隔离不同进程的访问权限

##  内存分配之堆和栈的区别

**堆**，优先队列(priority queue)；普通的队列是一种先进先出的数据结构

**栈**，先进后出(FILO—First-In/Last-Out)

栈由系统自动分配，速度较快；堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便
