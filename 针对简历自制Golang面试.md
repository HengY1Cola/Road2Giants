#### Q：Go语言的优势

1. 先进的并发编程模型
2. 拥有清晰的依赖管理与内置的垃圾回收
3. 标准库完善

#### Q：make与new的差别

make 关键字的主要作用是创建 slice、map 和 Channel 等内置的数据结构

new 的主要作用是为类型申请一片内存空间，并返回指向这片内存的指针

#### Q：[]rune/byte/strings

string就是只读的采用utf8编码的字节切片(slice)

byte就是单个的字节数组

rune是int32的别名，代表字符的Unicode编码，采用4个字节存储

#### Q：slice的扩容策略

如果旧切片的长度小于 1024，则最终容量就是旧容量的两倍

如果旧切片长度大于等于 1024，则最终容量从旧容量开始循环增加原来的 1/4

扩容的时候回进行搬家。

#### Q：slice底层

指针（传值的时候也是传的这个），cap，len

#### Q：slice传值

slice里面存的是指向数组的指针，所以传slice的值进去，也是可以改变底层数组的。

**但前提是，函数内部slice不会扩容**函数内部修改了这个指针，外面是看不到的

#### Q：slice的copy机制

copy执行后，目标切片的长度不会变，容量不会变但是

原切片和目标切片的内存空间可能会有重合，copy后可能会改变原切片的值

#### Q：map的底层

底层结构体是hmap，hmap里维护着若干个bucket数组

每个桶中保存了8个kv对，如果8个满了，又来了一个key落在了这个桶里，会使用overflow连接下一个桶

#### Q：map的Key类型

只要是可比较（可以使用==进行比较，两边的操作数可以相互赋值）的类型就可以；而map，slice和function不能作为Key的类型。

#### Q：对map进行并发访问时需增加同步机制

需要一种同步机制来保证访问数据的安全性。一种方式是使用`sync.RWMutex`

#### Q：channel的底层数据结构

对于有缓冲的channel存储数据，借助的是如下循环数组的结构

#### Q：channel 有缓冲与没有缓冲

无缓冲是同步的  有缓冲是异步的

#### Q：简述channel的日常用法

1. for range 2. 判断是否关闭 3. select处理

#### Q：关闭channel的注意事项

1. 一个 channel不能多次关闭 2. 向一个已经关闭了的 channel发送数据会导致panic

#### Q：recover的相关事项

1. 捕获到错误不会中止运行 2. `defer` + `recover` 组合 3. panic被recover()捕获，再次捕获为nil

#### Q：defer的相关事项

1. 局部传值 2. 满足后入先出 3. defer语句所在的函数的命名返回值做读取和修改操作

#### Q：Mutex 正常模式和饥饿模式

正常模式下，所有等待锁的协程按照先进先出顺序等待，唤醒的协程会和请求的协程竞争

饥饿模式下，新进来的goroutine 不会参与抢锁也不会进入自旋状态，会直接进入等待队列的尾部

#### Q：读写锁的理解

1. RWMutex 是单写多读锁，该锁可以加多个读锁或者一个写锁
2. 如果临界区的共享资源已被（读锁或写锁）锁定，这个写锁操作的 goroutine 将被阻塞直到解锁

#### Q：WaitGroup 实现原理

WaitGroup 主要维护了 2 个计数器，一个是请求计数器 v，一个是等待计数器 w

每次 Add 执行，请求计数器 v 加 1，Done 方法执行，等待计数器减 1，v 为0 时通过信号量唤醒 Wait()

#### Q：context上下文的理解与底层实现

context负责存放[协程](https://so.csdn.net/so/search?q=协程&spm=1001.2101.3001.7020)的当前信息（快照），其中包含着协程中的变量信息及函数调用。

如果此时有一个协程处理失败了，其他协程也应该立即关闭，避免持续占用系统资源。

context的调用是链式/树状的，如果一个节点被取消，该节点旗下的所有子context都将会被取消。

#### Q：Context使用场景

1. 上下文信息传递  2.  控制子 goroutine 的运行 3. 超时控制 4. 手动取消

#### Q：协程的优势

1. 在用户态对外透明
2. 用户态与内核态的切换减少
3. 轻量级线程，消耗资源较少
4. 可以恢复可以中断

#### Q：error，panic的区别与使用

**错误**指的是可能出现问题的地方出现了问题。比如打开一个文件时失败，这种情况在人们的意料之中

**异常**指的是不应该出现问题的地方出现了问题。比如引用了空指针，这种情况在人们的意料之外。

panic使用recover进行捕获

#### Q：协程与线程进程的区别

1. 用户态/内核态
2. 依赖调度器/抢占式
3. 应用层可以进行暂停与恢复/使用内核态的底层函数

#### Q：GMP模型的理解

> P 就像是一个流水线工人，而 P 的本地队列就是流水线，G 是流水线上的零件。而 Go 调度器就是流水线组长，负责监督工人的是不是有在努力的工作。把出品交给外面的M

G：4K一个=》几百万个 M：10000  P：内核数

若当前 P 的本地队列任务太多了，已经存放不下了，那么这个 goroutine 就只能放入到全局队列中

P 已经和某个线程进行绑定/P 已经从队列中（可以是本地队列，也可以是全局队列，甚至是从其他 P 的队列）取到该协程

#### Q：GMP模型为什么要有P

GM下：只存在全局队列，G被阻塞的话，M就会被会重新放内核队列中，等待新的一轮唤醒，导致线程经常被阻塞和解阻塞	

#### Q：调度器的设计策略

**work stealing 机制** 当本线程无可运行的 G 时，尝试从其他线程绑定的 P 偷取 G，而不是销毁线程

**hand off 机制** 当本线程因为 G 进行系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的线程执行。

#### Q：调度器的生命周期

初始化M0与G0 => 创建main的协程 => 启动M0 => 通过P获取到G

G0：G0 是每次启动一个 M 都会第一个创建的 gourtine，G0 仅用于负责调度的 G

#### Q：GC理解

垃圾回收只负责回收堆中的数据

使用了三色标记法 + 写屏障 + 辅助回收

#### Q：什么是三色标记法

三色标记法是属于追踪式垃圾回收算法的一种，判断一个对象是否可达，因为一旦这个对象不可达就可以立刻被 GC 回收了。

标记清扫：这个算法最大的问题是 GC 执行期间需要把整个程序完全暂停，不能异步进行 GC 操作

三色标记最大的好处是可以异步执行：等发现没有对象可以被置为灰色时，所有的白色变量就一定是需要被清理的垃圾了。

#### Q：简单说下一次完整的回收（为什么那两个 goroutine 不能并发运行？）

1. 阶段一：STW：打开 Write Barrier 前有一个依赖，我们需要先停止所有的 goroutine

2. 阶段二：**Marking** 标记 使用三色标记法

3. 阶段三：Mark Termination 标记结束：关闭掉已经打开了的 Write Barrier以及为下一次进行打算
4. 阶段四：Sweeping 清理：并发

#### Q：GC的触发条件

1. 主动触发(手动触发)，通过调用runtime.GC 来触发GC，此调用阻塞式地等待当前GC运行完毕.
2. 被动触发，分为两种方式：a. 使用系统监控，当超过两分钟没有产生任何GC时，强制触发 GC. b. 使用步调（Pacing）算法，其核心思想是控制内存增长的比例,当前内存分配达到一定比例则触发.

#### Q：什么是CAS

Go中的CAS操作是借用了CPU提供的原子性指令来实现。CAS操作修改共享变量时候不需要对共享变量加锁，而是通过类似乐观锁的方式进行检查，本质还是不断的占用CPU 资源换取加锁带来的开销（比如上下文切换开销）。

#### Q：内存逃逸

golang程序变量会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，它就可以在`栈上`分配。否则就说它 `逃逸` 了，必须在堆上分配

#### Q：什么情况下会发生内存逃逸？

1. **slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )**
2. **发送指针或带有指针的值到 channel 中**
3. **发送指针或带有指针的值到 channel 中**

#### Q： for ... range 语法中，变量会被复⽤

在一个循环中将 range 返回的变量值的地址赋值给另外一个新数组**正确的做法应该是使用 `&arr[i]` 替代 `&v`**



