#### Q：Mysql执行流程

获取 -》 缓存 -〉判断正确 -》 优化器 -〉 执行

#### Q：什么是事务？

事务就是一组原子性的SQL查询，要么全部执行成功，要么全部执行失败。

#### Q：什么是ACID特性

原子性/一致性/隔离性/持久性

#### Q：什么是脏读、不可重复读、幻读

脏读：之后A又对数据做了修改再提交，则B读到的数据是脏数据

不可重复读：再次读取以前读过的数据，却发现其读出的数据已经发生了变更、或者某些记录已经被删除了 (update/delete)

幻读：事务A在按查询条件读取某个范围的记录时，事务B又在该范围内插入了新的满足条件的记录

#### Q：MySQL事务的四个隔离级别分别是？

读未提交，读已提交，可重复读，可序列化

#### Q：Innodb是在第几个隔离层级

第三个：可重复读

#### Q：什么是MVCC

MVCC就是多版本并发控制。MVCC 是一种并发控制的方法，实现对数据库的并发访问

#### Q：简单说说MVCC

InnoDB 每一行数据都有一个隐藏的回滚指针，用于指向该行修改前的最后一个历史版本，这个历史版本存放在 undo log 中。

如果要执行更新操作，会将原记录放入 undo log 中，并通过隐藏的回滚指针指向 undo log 中的原记录。

其它事务此时需要查询时，就是查询 undo log 中这行数据的最后一个历史版本。

MVCC 最大的好处是读不加锁，读写不冲突，极大地增加了 MySQL 的并发性。通过 MVCC，保证了事务 ACID 中的隔离性特性。

#### Q：说说锁的粒度

按照**「锁的粒度」**划分可以分成：**「表锁、页锁、行锁」**

**「表锁」**是粒度最大的锁，开销小，加锁快，不会出现死锁，但是由于粒度太大，因此造成锁的冲突几率大，并发性能低。

**「行锁」**是粒度最小的锁机制，行锁的加锁开销性能大，加锁慢，并且会出现死锁，但是行锁的锁冲突的几率低，并发性能高。

#### Q：说说Innodb中的锁

InnoDB中除了有**「表锁」**和**「行级锁」**的概念，还有Gap Lock（间隙锁）

**间隙锁主要用于范围查询的时候，锁住查询的范围，并且间隙锁也是解决幻读的方案**

InnoDB中的行级锁是**「对索引加的锁，在不通过索引查询数据的时候，InnoDB就会使用表锁」**

#### Q：什么是共享锁/排他锁

共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。

排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁

#### Q：说说什么是乐观锁/悲观锁

乐观锁不是数据库自带的，需要我们自己去实现。乐观锁是指操作数据库时(更新操作)，想法很乐观，认为这次的操作不会导致冲突，在操作数据时，并不进行任何其他的特殊处理（也就是不加锁），而在进行更新后，再去判断是否有冲突了。

通常实现是这样的：在表中的数据进行操作时(更新)，先给数据表加一个版本(version)字段，每操作一次，将那条记录的版本号加1。也就是先查询出那条记录，获取出version字段,如果要对那条记录进行操作(更新),则先判断此刻version的值是否与刚刚查询出来时的version的值相等，如果相等，则说明这段期间，没有其他程序对其进行操作，则可以执行更新，将version字段的值加1；如果更新时发现此刻的version值与刚刚获取出来的version的值不相等，则说明这段期间已经有其他程序对其进行操作了，则不进行更新操作。

悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）

#### Q：InnoDB 和 MyISAM 

InnoDB 是 MySQL 的默认事务型存储引擎，也是最重要，使用最广泛的存储引擎。它被设计用来处理大量短期的事务。

MyISAM 不支持事务和行级锁，崩溃后无法恢复

事务/外键/索引/锁

#### Q：说说你知道的索引

1、从存储结构上来划分：BTree索引，Hash索引

2、从应用层次来分：主键索引，普通索引，唯一索引，全局索引

3、根据中数据的物理顺序与键值的逻辑（索引）顺序关系： 聚集索引，非聚集索引。

#### Q：为什么要使用B+树

1. B####tree磁盘读写代价更高
2. Hash虽然针对一个可以快速定位但是没有顺序，IO复杂度高且不支持范围查询且存在哈希碰撞的问题
3. 二叉树： 树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高
4. 红黑树： 树的高度随着数据量增加而增加，IO代价高

#### Q：聚簇索引与非聚簇索引的区别

1. 非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键
2. 通常情况下， 主键索引（聚簇索引）查询只会查一次，而非主键索引（非聚簇索引）需要回表查询多次。

#### Q：最左前缀原则/前缀索引

mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配 

order by不支持前缀索引 。

#### Q：什么情况下不走索引

1、使用!= 或者 <> 导致索引失效

2、函数导致的索引失效

3、运算符导致的索引失效

4、模糊搜索导致的索引失效

5、in 和not in，会导致数据库引擎放弃索引进行全表扫描

#### Q：慢SQL如何优化

打开慢日志开关 =》使用工具找出关键点

#### Q：Mysql如何性能优化

1. 物理上加内存
2. 系统配置上：数据预热 增大redo log 减少落盘
3. 表结构设计：冗余字段 拆表 主键优化
4. 索引与SQL：避免索引失效 ；使用慢查询log；expalin分析；尽量简单的SQL

#### Q：where/having/on的差别

WHERE是在GROUP BY之前执行的，所以WHERE的后面是不能使用聚合函数来进行数据过滤的，只能使用FROM表里的字段来进行数据过滤；HAVING是在GROUP BY之后执行的，那么这些数据就都已经分过组了的，可以使用聚合函数来进行数据的分组过滤。

ON支持左连接和右连接，WHERE是不支持的，WHERE里面只支持内连接，这在功能上是一个较大的区别

#### Q：redo log /binlog

binlog为逻辑日志记录SQL语句，采用追加的方式，主要用于主从以及数据恢复；刷盘时机可以选择哪几个事务刷一次

redolog：先将记录写入`redo log buffer`，后续某个时间点再一次性将多个操作记录写到`redo log file `循环写入的方式，当写到结尾时，会回到开头循环写日志。 用于崩溃时的数据恢复

#### Q：概述下Mysql页

为了避免一条一条读取磁盘数据，InnoDB采取页的方式，作为磁盘和内存之间交互的基本单位

#### Q：说一下InnoDB 逻辑存储结构

InnoDB 逻辑存储结构分为表空间（Tablespace）、段 (Segment)、区 (Extent)、页 Page) 以及行 (row)。

