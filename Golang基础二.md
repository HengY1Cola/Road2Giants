## Golang基础

###  连nil切片和空切片一不一样都不清楚？那BAT面试官只好让你回去等通知了

nil是全局指向一个地址而所有的空切片只向的是同一个地址。但是这两个地址并非同一个地址。

###  golang面试题：字符串转成byte数组，会发生内存拷贝吗？

会的，任何转形式都会发生内存的拷贝。但是也是有办法实现不拷贝的。

###  golang面试题：翻转含有中文、数字、英文字母的字符串

使用[]rune的操作+头尾指针交换

```go
package main

import"fmt"

func main() {
 src := "你好abc啊哈哈"
 dst := reverse([]rune(src))
 fmt.Printf("%v\n", string(dst))
}

func reverse(s []rune) []rune {
 for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
  s[i], s[j] = s[j], s[i]
 }
 return s
}
```

### golang面试题：拷贝大切片一定比小切片代价大吗？

是一样的，这个得深入源码发现切片的数据结构。只是len与cap的大小不一样，指针指向哪里的代价是一样的。

###  Golang如何并发操作Map

1. 加入互斥锁：高并发下的加锁解锁消耗太大了
2. 加入分段互斥锁：将一个Map分段，部分操作互不影响
3. 使用channel：将操作收集到管道中同步操作
4. 使用sync.map：在读多写少的情况下，读与写的操作分开操作。类似sync.RWMutex

###  深挖Go系列之读懂map的底层设计

- 对于map的扩容。针对有slice或者struct，因为`map`不可以对其值取地址，所以操作struct/slice中的值是不能被操作的，读是可以的。 只有把他们各自当做整体去赋值操作才是安全的。
- 对于map的初始化：不指定长度/小于8：只需要直接在堆上初始化`hmap`和 hash 种子；当大小大于 8，一些列桶优化操作

### golang中sort包用法

实现len；swap；less 

判断是否排序成功sort.IsSorted() 

根据定义排序sort.Sort(sortStruct(wantSortArray))

###  array和slice的区别

- 声明数组时，方括号内写明了数组的长度或者...,声明slice时候，方括号内为空
- 作为函数参数时，数组传递的是数组的副本，而slice传递的是指针。

### golang面试题：json包变量不加tag会怎么样？

- 如果变量`首字母小写`，则为`private`。无论如何`不能转`，因为取不到`反射信息`。

- 如果变量`首字母大写`，则为`public`。

- - `不加tag`，可以正常转为`json`里的字段，`json`内字段名跟结构体内字段`原名一致`。
  - `加了tag`，从`struct`转`json`的时候，`json`的字段名就是`tag`里的字段名，原字段名已经没用

###  golang面试题：reflect（反射包）如何获取字段tag？为什么json包不能导出私有变量的tag？

tag信息可以通过反射（reflect包）内的方法获取

```go
func printTag(stru interface{}) {
      t := reflect.TypeOf(stru).Elem()
      for i := 0; i < t.NumField(); i++ {
          fmt.Printf("结构体内第%v个字段 %v 对应的json tag是 %v , 还有otherTag？ = %v \n", i+1, t.Field(i).Name, t.Field(i).Tag.Get("json"), t.Field(i).Tag.Get("otherTag"))
   }
}
```

###  零切片、空切片、nil切片是什么

「零切片」其实并不是什么特殊的切片，它只是表示底层数组的二进制内容都是零

空切片、nil切片:nil是全局指向一个地址而所有的空切片只向的是同一个地址。但是这两个地址并非同一个地址。还有一个极为不同的地方在于 JSON 序列化

###  slice深拷贝和浅拷贝

浅拷贝：目的切片和源切片指向同一个底层数组，任何一个数组元素改变，都会同时影响两个数组。

深拷贝：目的切片和源切片指向不同的底层数组，任何一个数组元素改变都不影响另外一个。

###  map触发扩容的时机，满足什么条件时扩容？

哈希表在赋值、删除的动作下会触发扩容行为，条件如下

- 触发 `load factor` 的最大值，负载因子已达到当前界限
- 溢出桶 `overflow buckets` 过多

###  map扩容策略是什么

如果这次扩容是溢出的桶太多导致的，那么这次扩容就是等量扩容

等量扩容创建的新桶数量只是和旧桶一样，该函数中只是创建了新的桶，并没有对数据进行拷贝和转

如果这是等量扩容，那么旧桶与新桶之间是一对一的关系，所以两个 [`runtime.evacDst`](https://draveness.me/golang/tree/runtime.evacDst) 只会初始化一个。而当哈希表的容量翻倍时，每个旧桶的元素会都分流到新创建的两个桶中

###  make和new什么区别

- make 只能用来分配及初始化类型为 slice、map、chan 的数据。new 可以分配任意类型的数据；
- new 分配返回的是指针，即类型 *Type。make 返回引用，即 Type；
- new 分配的空间被清零。make 分配空间后，会进行初始化；

###  slice，len，cap，共享，扩容

- append一定要有返回值
- 当len = cap时 append会导致扩容，底层数组不再共享
- 在1024字节以内，扩容一倍，大于2014时，增加cap的1/4

###  Golang 之 struct能不能比较

都是可以比较/不能比较

- 同一个struct的两个实例能不能比较？ 当结构不包含不可直接比较成员变量时可直接比较，否则不可直接比较
- 两个不同的struct的实例能不能比较？

我们可以借助 *reflect.DeepEqual 函数* 来对两个变量进行比较

###  struct可以作为map的key么

struct必须是可比较的，才能作为key，否则编译时报错

###  map如何顺序读取？

对slice数组进行排序，然后就可以根据key值顺序读取map

- map 的 key 肯定是唯一的，而这恰好与 set 的特性一致，天然保证 set 中成员的唯一性。
- bitset 对集合操作有着天然的优势，直接通过位运算符便可实现

###  使用值为 nil 的 sice、map 会发生什么

允许对值为 nil 的 slice 添加元素，但对值为 nil 的 map 添加元素，则会造成运行时 panic。

###  Golang 有没有 this 指针

方法施加的对象显式传递，向对象表达更直观，对于面向过程只是换了一种语法形式来表达

###  Golang 语言中局部变量和全局变量的缺省值是什么

全局变量的缺省值是与这个类型相关的零值

###  Golang 中的引用类型包含哪些

1. map，无序的、键值对的集合；
2. pointers，计算机内存中变量所在的内存地址；只能读取指针的位置。
3. slice，数组的抽象；
4. channel，指管道，用于实现并行计算方程间通信；
5. interface，指接口，一组方法签名的集合；
6. function，指函数，不支持嵌套、重载和默认参数

###  Golang 使用range 迭代 map 为什么不是有序的

就是根据随机数，选择一个桶位置作为起始点进行遍历迭代

###  Golang 中指针运算有哪些

go语言指针是不支持运算的，也就是不支持++/--操作，但是我们借助于unsafe包，可以完成这个操作

用于指针运算，GC 不把 uintptr 当指针，uintptr 无法持有对象。**uintptr 类型的目标会被回收**

unsafe.Pointer 是桥梁，可以让任意类型的指针实现相互转换，也可以将任意类型的指针转换为 uintptr 进行指针运算

###  Golang 解析 JSON 数据时，默认将数值当做哪种类型

Go 默认会将数值当做float64 处理。

###  array 类型的值作为函数参数是引用传递还是值传递？

**在Go语言里，虽然只有传值，但是我们也可以修改原内容数据，因为参数是引用类型**

###  for select时，如果通道已经关闭会怎么样？如果select中只有一个case呢？

for循环`select`时，如果其中一个case通道已经关闭，则每次都会执行到这个case，但是ok是false

如果想跳过则可以重新设置为空。只有一个的话ok同样是false

###  对**未初始化**的的chan进行读写，会怎么样？**为什么？**

读写**未初始化**的`chan`都会阻塞

###  Golang select的使用及典型用法

select中的case语句必须是一个channel操作；select中的default子句总是可运行的。

1. 如果有多个case都可以运行，select会随机公平地选出一个执行，其他不会执行。
2. 如果没有可运行的case语句，且有default语句，那么就会执行default的动作。
3. 如果没有可运行的case语句，且没有default语句，select将阻塞，直到某个case通信可以运行

###  context包的用途

- WithValue携带数据
- withTimeout或者withDeadline来做超时控制
- withCancel取消控制

###  go defer（for defer）

- 碰见defer就会压入栈 后入先出
- 进入的值是复制
- 循环中使用 defer 时因为只有在函数执行完毕后，这些被延迟的函数才会执行，极有可能会导致内存泄漏

###  switch 中如何强制执行下一个 case 代码块

fallthrough强制执行后面的case代码，fallthrough不会判断下一条case的expr结果是否为true

###  如何从 panic 中恢复

recover只有在defer调⽤的函数中有效

###  能说说uintptr和unsafe.Pointer的区别吗？

- unsafe.Pointer只是单纯的通用指针类型，用于转换不同类型指针，它不可以参与指针运算；
- 而uintptr是用于指针运算的，GC 不把 uintptr 当指针，也就是说 uintptr 无法持有对象， uintptr 类型的目标会被回收；
- unsafe.Pointer是普通指针与uintptr中间桥梁

### 协程和线程的差别

1. 多个协程可由一个或多个线程管理，`协程的调度`发生在其所在的线程中。
2. 协程可以被调度，调度策略由应用层代码定义（Go来管理），即可被高度自定义实现。
3. 执行效率高。
4. 占用内存少。

###  垃圾回收的过程是怎么样的

简单地说，垃圾回收(GC)是在后台运行一个守护线程，它的作用是在监控各个对象的状态，识别并且丢弃不再使用的对象来释放和重用资源

当前Golang使用的垃圾回收机制是**三色标记法**配合**写屏障**和**辅助GC**，三色标记法是**标记-清除法**的一种增强版本

三色标记法：root区域主要是程序运行到当前时刻的栈和全局数据区域

1. 初始状态所有对象都是白色。
2. 从root根出发扫描所有根对象，将他们引用的对象标记为灰色
3. 分析灰色对象是否引用了其他对象。如果没有引用其它对象则将该灰色对象标记为黑色；如果有引用则将它变为黑色的同时将它引用的对象也变为灰色
4. 重复步骤3，直到灰色对象队列为空。此时白色对象即为垃圾，进行回收

写屏障：该**屏障之前的写操作和之后的写操作相比**，先被系统其它组件感知。 好难懂哦，结合上面GC工作的完整流程就好理解了，就是在每一轮GC开始时会初始化一个叫做“屏障”的东西，然后由它记录第一次scan时各个对象的状态，以便和第二次re-scan进行比对，引用状态变化的对象被标记为灰色以防止丢失，将屏障前后状态未变化对象继续处理。	

辅助GC：如果创建大于回收速度了，那么就会抢线程让用户的线程暂停拿过来加快垃圾回收。这样⼀来原来的并发还是变成了STW，还是得把⽤户线程暂停掉，要不然扫描和回收没完没了了停不下来，因为新分配对象⽐回收快，所以这种东⻄叫做辅助回收

###  怎么避免内存逃逸？

在`runtime/stubs.go:133`有个函数叫`noescape`。`noescape`可以在逃逸分析中**隐藏一个指针**。让这个指针在逃逸分析中不会被检测为逃逸

###  简单聊聊内存逃逸

golang程序变量`会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，它就可以在`栈上`分配。否则就说它 `逃逸` 了，必须在`堆上分配

能引起变量逃逸到堆上的**典型情况**：

- **在方法内把局部变量指针返回** 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。
- **发送指针或带有指针的值到 channel 中。** 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。
- **在一个切片上存储指针或带指针的值。** 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。
- **slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。** slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。
- **在 interface 类型上调用方法。** 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。

###  内存碎片化问题

内存碎片的问题，Go 是自己在用户态管理的，在 OS 层面看是没有碎片的，使得操作系统层面对碎片的管理压力也会降低

###  chan相关的goroutine泄露的问题

- 发送不接收：说白了就是留在channle中了，没取干净
- 接收不发送
- nil channel：不make
- 奇怪的慢等待：第三方接口不设置超时时间到个堆积发生泄漏
- 互斥锁忘记解锁
- 同步锁使用不当

###  string相关的goroutine泄露的问题

string相比于切片少了一个容量的cap字段，可以把string当成一个只读的切片类型。获取长string或切片中的一段内容，由于新生成的对象和老的string或切片共用一个内存空间，会导致老的string和切片资源暂时得不到释放，造成短暂的内存泄露。

###  sync.Pool的适用场景

一句话总结：保存和复用临时对象，减少内存分配，降低 GC 压力。

sync.Pool 用于存储那些被分配了但是没有被使用，而未来可能会使用的值

###  对已经关闭的的chan进行读写，会怎么样？为什么？

- 读**已经关闭**的 `chan` 能一直读到东西，但是读到的内容根据通道内`关闭前`是否有元素而不同。

- - 如果 `chan` 关闭前，`buffer` 内有元素**还未读** , 会正确读到 `chan` 内的值，且返回的第二个 bool 值（是否读成功）为 `true`。
  - 如果 `chan` 关闭前，`buffer` 内有元素**已经被读完**，`chan` 内无值，接下来所有接收的值都会非阻塞直接成功，返回 `channel` 元素的**零值**，但是第二个 `bool` 值一直为 `false`。

- 写**已经关闭**的 `chan` 会 `panic`

###  对未初始化的的chan进行读写，会怎么样？为什么？

读写**未初始化**的 `chan` 都会**阻塞**

###  sync.map 的优缺点和使用场景

map在并发情况虚啊，只读是线程安全的，同时写线程不安全，所以为了**并发安全 & 高效**，官方实现了一把。

优点：是官方出的，是亲儿子；通过读写分离，降低锁时间来提高效率； 缺点：不适用于大量写的场景，这样会导致read map读不到数据而进一步加锁读取，同时dirty map也会一直晋升为read map，整体性能较差。 适用场景：大量读，少量写

###  主协程如何等其余协程完再操作

- 方法一：channel 实现同步 判断最后的数量是否为0
- 方法二：使用无缓存的channel
- sync.WaitGroup

###  有缓存的channel和没有缓存的channel区别是什么

说明无缓部通道中，读取时如果没有数据写入，协程会阻塞至有数据写入。

缓冲的通道是没有阻塞等待的

###  协程通信方式有哪些

基本上就是推荐使用channel，这个是最推荐的使用形式；

还有就是使用`sync.Mutex`互斥锁进行加锁通讯

##  Golang拓展

###  Golang 大杀器之跟踪剖析 trace

- 在想查看的加入代码然后生成跟踪文件`go run main.go 2> trace.out`
- 启动可视化界面 `go tool trace trace.out`
- 一般先打开`Scheduler latency profile` 调度延迟概况
- 再打开`Goroutine analysis`查看每个协程的细节，这块能够很好的帮助我们**对 Goroutine 运行阶段做一个的剖析，可以得知到底慢哪，然后再决定下一步的排查方向**

- 再View trace

我们习得了 `go tool trace` 的武林秘籍，它能够跟踪捕获各种执行中的事件，例如 Goroutine 的创建/阻塞/解除阻塞，Syscall 的进入/退出/阻止，GC 事件，Heap 的大小改变，Processor 启动/停止等等。

###  pprof是一个好工具

https://mp.weixin.qq.com/s/d0olIiZgZNyZsO-OZDiEoA
